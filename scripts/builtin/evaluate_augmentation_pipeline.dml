#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# Evaluate Augmentation Pipeline
# TODO: short description
#
# INPUT PARAMETERS:
# ----------------------------------------------------------------------------------------------------------------------
# NAME       TYPE    DEFAULT MEANING
# ----------------------------------------------------------------------------------------------------------------------
# pipeline   Matrix  ---     Augmentation pipeline to evaluate
#                            Each row represents an augmentation policy
#                            For each image from the dataset an augmentation policy is chosen uniformly at random
#                            A policy consists of an arbitrary number of linearized transformation descriptions
#                            A transformation description consists of 3 values:
#                            * An integer defining the transformation
#                            * A double defining the probability of applying the transformation
#                            * A parameter value to apply to the transformation
# X_train    Matrix  ---     The training dataset consisting of linearized images.
                             Images are linearized in row-major format and one channel after the other.
# y_train    Vector  ---     The targets of the training set as a column vector
# X_test     Matrix  ---     The test dataset consisting of row-major linearized images.
# y_test     Vector  ---     The targets of the test set as a column vector
# width      Integer ---     The width of the images
# height     Integer ---     The height of the images
# channels   Integer   1     The number of channels of the images
# seed       Double   -1     The seed to use for random number generation

# RETURN VALUES
# ----------------------------------------------------------------------------------------------------------------------
# score      Double  ---     TODO: description
# ----------------------------------------------------------------------------------------------------------------------

m_evaluate_augmentation_pipeline = function(Matrix[Double] pipeline, Matrix[Double] X_train, Matrix[Double] y_train,
  Matrix[Double] X_test, Matrix[Double] y_test, Integer width, Integer height, Integer channels=1, Double seed=-1)
  return (Double score) {

  s_transform = 3
  n_samples = nrow(X_train)
  n_policies = nrow(pipeline)
  n_transforms = ncol(pipeline) / s_transform

  random = rand(rows=n_samples, cols=n_transforms+1, min=0, max=1, sparsity=1, pdf="uniform", seed=seed)

  # apply augmentation pipeline to the training set
  for (i in 1:n_samples) {
    img = matrix(X_train[i], rows=height, cols=width)
    policy_idx = as.scalar(floor(random[i, 1] * n_policies)) + 1
    for (j in 1:n_transforms) {
      transform_idx = (j-1)*s_transform
      operation = as.scalar(pipeline[policy_idx, transform_idx + 1])
      prob = as.scalar(pipeline[policy_idx, transform_idx + 2])
      param = as.scalar(pipeline[policy_idx, transform_idx + 3])

      if (as.scalar(random[i, j+1]) < prob) {
        # TODO: apply transformation operation using param
      }
    }
  }

  # TODO: create a submodel and train it using the augmented X_train
  # TODO: evaluate the submodel on the testset
  score = 0
}
